#!/usr/bin/env python3

"""
ttymol -- terminal molecule viewer/editor
- Molecular geometry viewer
- Animation of molecular vibrations
- Animation of trajectory
- Simple molecule editor

Supported filetypes
- Gaussian output  : Geometry & Vibrations
- Molpro output    : Geometry & Vibrations
- XYZ (single geometry)      : Geometry
- XYZ (multiple geometries)  : Trajectory


Usage
$ ttymol.py [options] [file]

Options:
  -h, --help     print the help message and exit
  -v, --version  print the version and exit

"""

__version__ = "0.1"

import sys
import os
import math
import time
try:
    import curses
    import curses.textpad
    _curses_supported = True
except ImportError:
    _curses_supported = False

_atom_name = ['X', 'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O',
              'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca',
              'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge',
              'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru',
              'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe']
_atom_mass = [0.0,
              1.007825037, 4.00260325, 7.0160045, 9.0121825, 
              11.0093053, 12.0, 14.003074008, 15.99491464, 
              18.99840325, 19.9924391, 22.9897697, 23.985045,
              26.9815413, 27.9769284, 30.9737634, 31.9720718,
              34.968852729, 39.9623831, 38.9637079, 39.9625907, 
              44.9559136, 47.9479467, 50.9439625, 51.9405097,
              54.9380463, 55.9349393, 58.9331978, 57.9353471,
              62.9295992, 63.9291454, 68.9255809, 73.9211788,
              74.9215955, 79.9165205, 78.9183361, 83.9115064, 
              84.9117, 87.9056, 88.9054, 89.9043,
              92.906, 97.9055, 98.9063, 101.9037, 
              102.9048, 105.9032, 106.90509, 113.9036, 
              114.9041, 117.9018, 120.9038, 129.9067,
              126.9004, 131.9042]
_atom_brad = [1.0, 1.4, 1.7, 1.7, 1.7, 1.7, 1.7, 1.7, 1.7, 1.7, 1.7]
for i in range(len(_atom_name) - len(_atom_brad)):
    _atom_brad.append(1.8)
    
_aname = dict(list(zip(list(range(len(_atom_name))), _atom_name)))
_amass = dict(list(zip(_atom_name, _atom_mass)))
_abrad = dict(list(zip(_atom_name, _atom_brad)))

_b2a = 0.52917721092


class Molecule(object):
    
    def __init__(self, atoms=None, coord=None, note="test", vibfreq=None, vibmode=None):
        if atoms is None: atoms = []
        if coord is None: coord = []
        if vibfreq is None: vibfreq = []
        if vibmode is None: vibmode = []
        self.setCoord(atoms, coord, note)
        self.setVib(vibfreq, vibmode)

    def setCoord(self, atoms, coord, note="test"):
        self.natoms = len(atoms)
        self.atoms = atoms
        self.orig_coord = coord
        self.note = note
        if self.natoms > 0:
            self.setCom(self.orig_coord)
        self.restoreCoord()
        
    def setCom(self, coord=None):
        if coord is None: coord = self.coord
        com = [0., 0., 0.]
        mtot = 0.
        for i in range(self.natoms):
            m = _amass[self.atoms[i]]
            mtot += m
            for j in range(3): com[j] += m * coord[i][j]
        for i in range(3): com[i] /= mtot
        for i in range(self.natoms):
            for j in range(3): coord[i][j] -= com[j]
        return

    def restoreCoord(self):
        self.coord = [[x, y, z] for x, y, z in self.orig_coord]

    def setVib(self, vibfreq, vibmode):
        self.vibfreq = vibfreq
        self.vibmode = vibmode

    def save(self, fn):
        title = "generated by ttymol ver.%s on %s" \
                % (__version__, time.strftime("%Y-%m-%d %H:%M:%S"))
        ext = os.path.splitext(fn)[1]
        if ext in (".xyz",): self.saveXyz(fn, title)
        elif ext in (".gjf", ".inp"): self.saveGaussian(fn, title)
        elif ext in (".mlp",): self.saveMolpro(fn, title)
        else: self.saveXyz(fn, title)
        return True

    def saveXyz(self, fn, title):
        fp = open(fn, "w")
        fp.write("%d\n" % self.natoms)
        fp.write("%s\n" % title)
        for i in range(self.natoms):
            fp.write("%2s  % 12.8f  % 12.8f  % 12.8f\n"
                     % (self.atoms[i], self.coord[i][0], 
                        self.coord[i][1], self.coord[i][2]))
        return
    
    def saveGaussian(self, fn, title):
        fp = open(fn, "w")
        fp.write("# test\n\n")
        fp.write("%s\n\n" % title)
        fp.write("0 1\n")
        for i in range(self.natoms):
            fp.write("%2s  % 12.8f  % 12.8f  % 12.8f\n"
                     % (self.atoms[i], self.coord[i][0], 
                        self.coord[i][1], self.coord[i][2]))
        fp.write("\n")
        return

    def saveMolpro(self, fn, title):
        fp = open(fn, "w")
        fp.write("***,%s\n\n" % title)
        fp.write("geometry={ang;\n")
        for i in range(self.natoms):
            fp.write("%2s  0 % 12.8f  % 12.8f  % 12.8f\n"
                     % (self.atoms[i], self.coord[i][0], 
                        self.coord[i][1], self.coord[i][2]))
        fp.write("}\n")
        return
    
    def setCoordFromXyzFile(self, xyzfn):
        fp = open(xyzfn)
        self.setCoordFromXyzFp(fp)
        fp.close()

    def setCoordFromXyzFp(self, fp):
        natoms = int(next(fp).strip())
        note = next(fp).strip()
        atoms, coord = [], []
        for i in range(natoms):
            ls = next(fp).split()
            atoms.append(ls[0])
            coord.append(list(map(float,ls[1:4])))
        self.setCoord(atoms, coord, note)

    def setFromGaussian(self, fn):
        fp = open(fn)
        atoms, coord, vibfreq, vibmode = [], [], [], []
        for l in fp:
            # atoms and coordinates
            if l.strip() in ("Standard orientation:", "Input orientation:", 
                             "Z-Matrix orientation:"):
                atoms = []
                coord = []
                for i in range(4): next(fp)
                l = next(fp)
                while not l.startswith(" --------"):
                    ls = l.split()
                    if (len(ls) == 6 and 
                        ls[0].isdigit() and ls[1].isdigit() and ls[2].isdigit()):
                        atoms.append(_aname[int(ls[1])])
                        coord.append(list(map(float, ls[3:6])))
                    else:
                        break
                    l = next(fp)
                natoms = len(atoms)
            # frequencies output
            if l.startswith(" Harmonic frequencies"):
                vibfreq = []
                vibmode = []
            # vibfreq
            if l.startswith(" Frequencies --"):
                freqs = list(map(float, l.split()[2:]))
                vibfreq.extend(freqs)
            # vibmode
            ls = l.split()
            if ((len(ls) > 2) and ((len(ls) - 2) % 3 == 0)
                and (ls[0] == "Atom") and (ls[1] == "AN")
                and all(x in "XYZ" for x in ls[2:])):
                ls = l.split()[2:]
                if len(ls) % 3 == 0 and all(x in "XYZ" for x in ls):
                    nmodes = int(len(ls) / 3)
                    modes = [[] for i in range(nmodes)]
                    for i in range(natoms):
                        l = next(fp)
                        values = list(map(float, l.split()[2:]))
                        for j in range(nmodes):
                            modes[j].append(values[3*j:3*j+3])
                    vibmode.extend(modes)
        self.setCoord(atoms, coord, "Gaussian output file")
        self.setVib(vibfreq, vibmode)
        return

    def setFromMolpro(self, fn):
        fp = open(fn)
        atoms, coord, vibfreq, vibmode = [], [], [], []
        vibsign = 1
        for l in fp:
            # atoms and coordinates
            if l.lower().startswith(" atomic coordinates"):
                atoms = []
                coord = []
                for i in range(3): next(fp)
                l = next(fp)
                while l.strip() != "":
                    ls = l.split()
                    atoms.append(ls[1])
                    coord.append([float(x)*_b2a for x in ls[3:6]])
                    l = next(fp)
                natoms = len(atoms)
            # frequencies output
            if l.startswith(" Frequencies dumped to record"):
                vibfreq = []
                vibmode = []
            if l.strip() == "Normal Modes": vibsign = 1
            if l.strip() == "Normal Modes of low/zero frequencies": vibsign = 1
            if l.strip() == "Normal Modes of imaginary frequencies": vibsign = -1
            # vibfreq
            if l.startswith(" Wavenumbers [cm-1]"):
                freqs = [vibsign*float(x) for x in l.split()[2:]]
                vibfreq.extend(freqs)
                for i in range(2): next(fp)
                nmodes = len(freqs)
                modes = [[] for i in range(nmodes)]
                for i in range(natoms):
                    xval = list(map(float, next(fp).split()[1:]))
                    yval = list(map(float, next(fp).split()[1:]))
                    zval = list(map(float, next(fp).split()[1:]))
                    for j in range(nmodes):
                        modes[j].append([xval[j], yval[j], zval[j]])
                vibmode.extend(modes)
        self.setCoord(atoms, coord, "Molpro output file")
        self.setVib(vibfreq, vibmode)
        return

    def getMaxDist(self):
        maxdist = 1.
        for i in range(self.natoms):
            x, y, z = self.coord[i]
            dist = math.sqrt(x*x + y*y + z*z) + 0.5 * _abrad[self.atoms[i]]
            if maxdist < dist: maxdist = dist
        return maxdist

    def vibrateCoord(self, nmode, disp):
        if nmode > len(self.vibmode): return
        vmode = self.vibmode[nmode]
        for i in range(self.natoms):
            self.coord[i] = [self.orig_coord[i][j] + disp*vmode[i][j] for j in range(3)]
        return

    def writeScreen(self, scr, cam, camtop, camright, hposrange, wposrange, 
                    maxdist, zoom, bond=True, hasnum=False, selected=None):
        hmin, hmax = hposrange
        wmin, wmax = wposrange
        cent = (int((hmin + hmax)/2), int((wmin + wmax)/2))
        diff = min((wmax - wmin)/2, hmax - hmin)
        scale = diff / (2. * maxdist)
        
        hwd = []
        camlen = math.sqrt(sum(x*x for x in cam))
        camtoplen = math.sqrt(sum(x*x for x in camtop))
        camrightlen = math.sqrt(sum(x*x for x in camright))
        for i in range(self.natoms):
            dlen = -sum(cam[j]*self.coord[i][j] for j in range(3)) / camlen
            coordp = [self.coord[i][j]+cam[j]*dlen for j in range(3)]
            hlen = sum(camtop[j]*coordp[j] for j in range(3)) / camtoplen
            wlen = sum(camright[j]*coordp[j] for j in range(3)) / camrightlen
            hwd.append([hlen, wlen, dlen])
        
        positions = []
        for i in range(self.natoms):
            hpos = int(- hwd[i][0] * scale * zoom + cent[0])
            wpos = int(2 * hwd[i][1] * scale * zoom + cent[1])
            positions.append((hpos, wpos))

        if bond:
            for i in range(self.natoms):
                crit1 = _abrad[self.atoms[i]]
                for j in range(i+1,self.natoms):
                    crit2 = _abrad[self.atoms[j]]
                    vec = [hwd[j][k] - hwd[i][k] for k in range(3)]
                    thislen = (vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2])**0.5
                    if thislen > 0.5*(crit1+crit2): continue
                    hpos1, wpos1 = positions[i]
                    hpos2, wpos2 = positions[j]
                    nst = max(int(((hpos2-hpos1)**2 + (wpos2-wpos1)**2)**0.5), 1)
                    for k in range(nst+1):
                        hpos = int(hpos1 + (hpos2 - hpos1) * k / float(nst))
                        wpos = int(wpos1 + (wpos2 - wpos1) * k / float(nst))
                        d = hwd[i][2] + hwd[j][2] * k / float(nst)
                        if d < 0: attr = curses.A_BOLD
                        else: attr = curses.A_NORMAL
                        if (hmin <= hpos <= hmax) and (wmin <= wpos <= wmax):
                            scr.addstr(hpos, wpos, ".", attr)
        
        depthinds = [(hwd[i][2], i) for i in range(self.natoms)]
        depthinds = sorted(depthinds, reverse=True)
        labels = self.atoms
        if hasnum: labels = [labels[i]+str(i+1) for i in range(self.natoms)]
        for d, i in depthinds:
            hpos, wpos = positions[i]
            if selected == i: attr = curses.A_STANDOUT
            elif d < 0: attr = curses.A_BOLD
            else: attr = curses.A_NORMAL
            if (hmin <= hpos <= hmax) and (wmin <= wpos <= (wmax - (len(labels[i])))):
                scr.addstr(hpos, wpos, labels[i], attr)
        return


def getMolecules(fn):
    fp = open(fn)
    maxdist = 0.
    molecules = []
    while True:
        try:
            mlc = Molecule()
            mlc.setCoordFromXyzFp(fp)
        except StopIteration:
            break
        maxdist1 = mlc.getMaxDist()
        if maxdist < maxdist1: maxdist = maxdist1
        molecules.append(mlc)
    fp.close()
    return molecules, maxdist

def rotateAround(pos, ax, theta):
    x, y, z = pos
    a, b, c = ax
    sin = math.sin(theta)
    cos = math.cos(theta)
    cosm = 1. - math.cos(theta)
    x2 = (a*a*cosm+cos)*x + (a*b*cosm-c*sin)*y + (c*a*cosm+b*sin)*z
    y2 = (a*b*cosm+c*sin)*x + (b*b*cosm+cos)*y + (b*c*cosm-a*sin)*z
    z2 = (c*a*cosm-b*sin)*x + (b*c*cosm+a*sin)*y + (c*c*cosm+cos)*z
    return [x2, y2, z2]

def traj(scr, fn, typ="xyztraj"):
    molecules, maxdist = getMolecules(fn)
    totnum = len(molecules)
    hmax, wmax = scr.getmaxyx()
    cam, camtop = [0., 0., -1.], [0., 1., 0.]
    zoom = 1.0
    interval = 20
    num = 0
    hasnum = False
    stop = False
    reverse = False
    bond = True
    while True:
        scr.erase()
        mlc = molecules[num]

        # header
        text = " " + fn + ("(%d/%d): " % (num+1, totnum))
        text += mlc.note
        if len(text) > wmax-1: text = text[:wmax-1]
        rest = wmax - len(text)
        text += " " * rest
        scr.addstr(0, 0, text, curses.A_REVERSE)

        # footer
        cmds = ["(q)uit", "(f)ast", "(s)low", 
                "(SPC)start" if stop else "(SPC)stop", 
                "(r)everse", "(p)rev", "(n)ext", "(HOME/END)",
                "(+-)zoom", "(CUR)rotate", "(o)rient",
                "(b)ond", "(l)abel", "(e)dit"
                ]
        footers = [cmds[0]]
        for cmd in cmds[1:]:
            if (len(footers[-1]) + len(cmd) + 1) < wmax-1:
                footers[-1] = footers[-1] + " " + cmd
            else:
                footers.append(cmd)
        footers[-1] = footers[-1] + ":"
        for i in range(len(footers)):
            scr.addstr(hmax-len(footers)+i, 0, footers[i])

        # bar
        text = "% 5d ms, %d%% " % (interval, zoom*100)
        lenprog = wmax - len(text) - 2
        nprog  = int((num+1) / float(totnum) * lenprog)
        if nprog > lenprog: nprog = lenprog
        nunprog = lenprog - nprog
        text += "[" + ("="*nprog) + (" "*nunprog) + "]"
        scr.addstr(hmax-1-len(footers), 0, text, curses.A_REVERSE)

        # molecule
        camright = [cam[1]*camtop[2] - cam[2]*camtop[1],
                    cam[2]*camtop[0] - cam[0]*camtop[2],
                    cam[0]*camtop[1] - cam[1]*camtop[0]]
        mlc.writeScreen(scr, cam, camtop, camright, 
                        (1, hmax-2-len(footers)), (0, wmax-1),
                        maxdist, zoom, bond=bond, hasnum=hasnum)
        
        # show
        scr.move(hmax-1, len(footers[-1]))
        scr.refresh()
        #curses.napms(interval)
        time.sleep(interval*1e-3)
        
        # command
        rottop, rotright = None, None
        ch = scr.getch()
        curses.flushinp()
        if ch >= 0 and ch < 256: c = chr(ch)
        else: c = ""
        
        if c == "q": break
        elif c == "s": interval = min(interval+1, 1000)
        elif c == "f": interval = max(interval-1, 1)
        elif c == " ": stop = not stop
        elif c == "r": reverse = not reverse
        elif c == "p": num -= 1
        elif c == "n": num += 1
        elif ch == curses.KEY_HOME: num = 0
        elif ch == curses.KEY_END: num = totnum-1
        elif c == "+": zoom += 0.01
        elif c == "-": zoom = max(zoom-0.01, 0.01)
        elif ch == curses.KEY_UP: rottop = -1.
        elif ch == curses.KEY_DOWN: rottop = 1.
        elif ch == curses.KEY_RIGHT: rotright = 1.
        elif ch == curses.KEY_LEFT: rotright = -1.
        elif c == "o": cam, camtop = [0., 0., -1.], [0., 1., 0.]
        elif c == "b": bond = not bond
        elif c == "l": hasnum = not hasnum
        elif c == "e": edit(scr, fn, mlc)
        elif ch == curses.KEY_RESIZE:
            hmax, wmax = scr.getmaxyx()
        
        if not stop:
            if reverse: num -= 1
            else: num += 1
        if num < 0: num = 0
        if num > totnum-1: num = totnum-1
            
        if rottop is not None:
            cam = rotateAround(cam, camright, math.pi * rottop / 90.)
            camtop = rotateAround(camtop, camright, math.pi * rottop / 90.)
        if rotright is not None:
            cam = rotateAround(cam, camtop, math.pi * rotright / 90.)
            camtop = rotateAround(camtop, camtop, math.pi * rotright / 90.)

    return

def geomvib(scr, fn, typ):
    mlc = Molecule()
    if typ == "xyz": mlc.setCoordFromXyzFile(fn)
    elif typ == "gaussian": mlc.setFromGaussian(fn)
    elif typ == "molpro": mlc.setFromMolpro(fn)
    else: return False
    
    maxdist = mlc.getMaxDist()
    hmax, wmax = scr.getmaxyx()
    cam, camtop = [0., 0., -1.], [0., 1., 0.]
    zoom = 1.0
    interval = 20
    nconf = 0
    nshift = 0
    configs = ["geometry"] + mlc.vibfreq
    hasvib = (len(configs) > 1)
    vibmaxdisp = 1.
    vibphase = 0.
    hasnum = False
    stop = False
    reverse = False
    bond = True
    while True:
        scr.erase()
    
        # header
        text = " " + fn + ": "
        text += mlc.note
        if len(text) > wmax-1: text = text[:wmax-1]
        rest = wmax - len(text)
        text += " " * rest
        scr.addstr(0, 0, text, curses.A_REVERSE)

        # config
        wconf = 14
        if wconf > wmax-3: wconf = wmax-3
        for i in range(1, hmax-2): scr.addstr(i, wconf, "|")
        if nconf - nshift > hmax-6: nshift = nconf - (hmax-6)
        if nconf - nshift < 0: nshift = nconf
        for i in range(len(configs)):
            if i+2 > hmax-4: break
            ithis = i + nshift
            if ithis == 0: string = "% 12s" % (configs[ithis])
            else: string = "% 3s: % 7.1f" % (ithis, configs[ithis])
            if len(string) > wconf-2: string = string[:wconf-2]
            if ithis == nconf: attr = curses.A_REVERSE
            else: attr = curses.A_NORMAL
            scr.addstr(i+2, 1, string, attr)
        
        # footer
        cmds = ["(q)uit"]
        if hasvib:
            cmds += ["(PgUp/Dn/HOME/END)select"]
        if hasvib and nconf > 0:
            cmds += ["(f)ast", "(s)low", 
                     "(SPC)start" if stop else "(SPC)stop", 
                     "(r)everse", "(p)rev", "(n)ext", "(<>)maxdisp"]
        cmds += ["(+-)zoom", "(CUR)rotate", "(o)rient", 
                 "(b)ond", "(l)abel", "(e)dit"]
        footers = [cmds[0]]
        for cmd in cmds[1:]:
            if (len(footers[-1]) + len(cmd) + 1) < wmax-1:
                footers[-1] = footers[-1] + " " + cmd
            else:
                footers.append(cmd)
        footers[-1] = footers[-1] + ":"
        for i in range(len(footers)):
            scr.addstr(hmax-len(footers)+i, 0, footers[i])
        
        # bar
        text = "% 5d ms, %d%%" % (interval, zoom*100)
        if hasvib:
            text += ", maxdisp = %.2f" % (vibmaxdisp)
            text += ", vibphase = %.2f" % (math.sin(vibphase))
        if len(text) > wmax-1: text = text[:wmax-1]
        rest = wmax - len(text)
        text += " " * rest
        scr.addstr(hmax-1-len(footers), 0, text, curses.A_REVERSE)

        # molecule
        if hasvib:
            if nconf > 0: mlc.vibrateCoord(nconf-1, vibmaxdisp * math.sin(vibphase))
            else: mlc.restoreCoord()
        camright = [cam[1]*camtop[2] - cam[2]*camtop[1],
                    cam[2]*camtop[0] - cam[0]*camtop[2],
                    cam[0]*camtop[1] - cam[1]*camtop[0]]
        mlc.writeScreen(scr, cam, camtop, camright,
                        (1, hmax-2-len(footers)), (wconf+1, wmax-1),
                        maxdist, zoom, bond=bond, hasnum=hasnum)

        # show
        scr.move(hmax-1, len(footers[-1]))
        scr.refresh()
        #curses.napms(interval)
        time.sleep(interval*1e-3)

        # command
        nconf_old = nconf
        rottop, rotright = None, None
        ch = scr.getch()
        curses.flushinp()
        if ch >=0 and ch < 256: c = chr(ch)
        else: c = ""
        
        if c == "q": break
        elif hasvib and ch == curses.KEY_PPAGE: nconf = max(nconf-1, 0)
        elif hasvib and ch == curses.KEY_NPAGE: nconf = min(nconf+1, len(configs)-1)
        elif hasvib and ch == curses.KEY_HOME: nconf = 0
        elif hasvib and ch == curses.KEY_END: nconf = len(configs)-1
        elif hasvib and nconf > 0 and c == "s": interval = min(interval+1, 1000)
        elif hasvib and nconf > 0 and c == "f": interval = max(interval-1, 1)
        elif hasvib and nconf > 0 and c == " ": stop = not stop
        elif hasvib and nconf > 0 and c == "r": reverse = not reverse
        elif hasvib and nconf > 0 and c == "p": vibphase -= math.pi / 30.
        elif hasvib and nconf > 0 and c == "n": vibphase += math.pi / 30.
        elif hasvib and nconf > 0 and c == "<": vibmaxdisp -= 0.05
        elif hasvib and nconf > 0 and c == ">": vibmaxdisp += 0.05
        elif c == "+": zoom += 0.01
        elif c == "-": zoom = max(zoom-0.01, 0.01)
        elif ch == curses.KEY_UP: rottop = -1.
        elif ch == curses.KEY_DOWN: rottop = 1.
        elif ch == curses.KEY_RIGHT: rotright = 1.
        elif ch == curses.KEY_LEFT: rotright = -1.
        elif c == "o": cam, camtop = [0., 0., -1.], [0., 1., 0.]
        elif c == "b": bond = not bond
        elif c == "l": hasnum = not hasnum
        elif c == "e": 
            isquit = edit(scr, fn, mlc)
            if isquit: break
        elif ch == curses.KEY_RESIZE:
            hmax, wmax = scr.getmaxyx()

        if hasvib and nconf > 0:
            if nconf != nconf_old: 
                vibphase = 0.
            elif not stop:
                if reverse: vibphase -= math.pi / 30.
                else: vibphase += math.pi / 30.
                if vibphase > 2.*math.pi: vibphase -= 2.*math.pi
                if vibphase < 0.: vibphase += 2.*math.pi
        else:
            vibphase = 0.
        
        if rottop is not None:
            cam = rotateAround(cam, camright, math.pi * rottop / 90.)
            camtop = rotateAround(camtop, camright, math.pi * rottop / 90.)
        if rotright is not None:
            cam = rotateAround(cam, camtop, math.pi * rotright / 90.)
            camtop = rotateAround(camtop, camtop, math.pi * rotright / 90.)

    return

def edit(scr, fn, mlc):
    maxdist = mlc.getMaxDist()
    hmax, wmax = scr.getmaxyx()
    cam, camtop = [0., 0., -1.], [0., 1., 0.]
    zoom = 1.0
    interval = 20
    dstep = 0.01
    hasnum = True
    bond = True
    isquit = False
    edited = False
    selected = -1
    while True:
        scr.erase()
        if selected > mlc.natoms - 1: selected = mlc.natoms - 1
        if selected < 0 and mlc.natoms > 0: selected = 0
        if mlc.natoms == 0: selected = -1
        
        # header
        if edited: text = " *" + fn + ": "
        else: text = " " + fn + ": "
        text += mlc.note
        if len(text) > wmax-1: text = text[:wmax-1]
        rest = wmax - len(text)
        text += " " * rest
        scr.addstr(0, 0, text, curses.A_REVERSE)
        
        # config
        wconf = 14
        if wconf > wmax-3: wconf = wmax-3
        for i in range(1, hmax-2): scr.addstr(i, wconf, "|")
        labels = [mlc.atoms[i]+str(i+1) for i in range(mlc.natoms)]
        if selected >= 0:
            string = labels[selected]
            if len(string) > wconf-2: string = string[:wconf-2]
            scr.addstr(2, 1, string, curses.A_STANDOUT)
            bonds = []
            for i in range(len(labels)):
                if i == selected: continue
                vec = [mlc.coord[selected][j] - mlc.coord[i][j] for j in range(3)]
                thislen = (vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2])**0.5
                bonds.append((thislen, labels[i]))
            bonds = sorted(bonds)
            for i in range(len(bonds)):
                if i +3 > hmax-4: break
                string = "-%-3s: %6.3f" % (bonds[i][1], bonds[i][0])
                if len(string) > wconf-2: string = string[:wconf-2]
                scr.addstr(i+3, 1, string)
        
        # footer
        cmds = ["(q)uit"]
        if selected >= 0:
            cmds += ["(p)rev", "(n)ext", "(x|y|z)+", "(X|Y|Z)-",
                     "(<>)step", "(c)enter", "(+-)zoom", "(CUR)rotate", 
                     "(o)rient", "(b)ond", "(l)abel"]
        cmds += ["(r)eset", "(s)ave", "(e)nd"]
        footers = [cmds[0]]
        for cmd in cmds[1:]:
            if (len(footers[-1]) + len(cmd) + 1) < wmax-1:
                footers[-1] = footers[-1] + " " + cmd
            else:
                footers.append(cmd)
        footers[-1] = footers[-1] + ":"
        for i in range(len(footers)):
            scr.addstr(hmax-len(footers)+i, 0, footers[i])

        # bar
        text = "edit, %d%%" % (zoom*100)
        if selected >= 0:
            x, y, z = mlc.coord[selected]
            text += ", (%.3f, %.3f, %.3f)" % (x, y, z)
        text += ", step = %.3f" % (dstep)
        if len(text) > wmax-1: text = text[:wmax-1]
        rest = wmax - len(text)
        text += " " * rest
        scr.addstr(hmax-1-len(footers), 0, text, curses.A_REVERSE)

        # molecule
        camright = [cam[1]*camtop[2] - cam[2]*camtop[1],
                    cam[2]*camtop[0] - cam[0]*camtop[2],
                    cam[0]*camtop[1] - cam[1]*camtop[0]]
        mlc.writeScreen(scr, cam, camtop, camright,
                        (1, hmax-2-len(footers)), (wconf+1, wmax-1),
                        maxdist, zoom, bond=bond, hasnum=hasnum,
                        selected=selected)
        # show
        scr.move(hmax-1, len(footers[-1]))
        scr.refresh()
        #curses.napms(interval)
        time.sleep(interval*1e-3)
        
        # command
        isexit = False
        issave = False
        rottop, rotright = None, None
        ch = scr.getch()
        curses.flushinp()
        if ch >=0 and ch < 256: c = chr(ch)
        else: c = ""
        
        if c == "q": isquit = True
        elif c == "p": selected -= 1
        elif c == "n": selected += 1
        elif selected >= 0 and c == "x": 
            mlc.coord[selected][0] += dstep
            edited = True
        elif selected >= 0 and c == "X":
            mlc.coord[selected][0] -= dstep
            edited = True
        elif selected >= 0 and c == "y":
            mlc.coord[selected][1] += dstep
            edited = True
        elif selected >= 0 and c == "Y":
            mlc.coord[selected][1] -= dstep
            edited = True
        elif selected >= 0 and c == "z": 
            mlc.coord[selected][2] += dstep
            edited = True
        elif selected >= 0 and c == "Z":
            mlc.coord[selected][2] -= dstep
            edited = True
        elif c == "<": dstep = max(dstep-0.001, 0.001)
        elif c == ">": dstep += 0.001
        elif c == "c": mlc.setCom()
        elif c == "+": zoom += 0.01
        elif c == "-": zoom = max(zoom-0.01, 0.01)
        elif ch == curses.KEY_UP: rottop = -1.
        elif ch == curses.KEY_DOWN: rottop = 1.
        elif ch == curses.KEY_RIGHT: rotright = 1.
        elif ch == curses.KEY_LEFT: rotright = -1.
        elif c == "o": cam, camtop = [0., 0., -1.], [0., 1., 0.]
        elif c == "b": bond = not bond
        elif c == "l": hasnum = not hasnum
        elif c == "r": mlc.restoreCoord()
        elif c == "s": issave = True
        elif c == "e": isexit = True
        elif ch == curses.KEY_RESIZE:
            hmax, wmax = scr.getmaxyx()
            
        if isquit or isexit:
            #if not edited: break
            break
        
        if issave:
            text = "Save to (C-g to cancel) [*.xyz(XYZ)|*.gjf(Gaussian)|*.mlp(Molpro)]:"
            if len(text) > wmax-1: text = text[:wmax-1]
            rest = wmax - len(text)
            text += " " * rest
            scr.addstr(hmax-2, 0, text, curses.A_REVERSE)
            scr.refresh()
            savewin = curses.newwin(1, wmax, hmax-1, 0)
            def checkch(ch):
                if ch == curses.ascii.BEL: savewin.erase() # C-g for cancel
                return ch
            textbox = curses.textpad.Textbox(savewin)
            savefn = textbox.edit(checkch).strip()
            dosave = (savefn != "")
            if dosave and os.path.exists(savefn):
                text = "Overwrite \"%s\" ? [y/n]:" % savefn
                if len(text) > wmax-1: text = text[:wmax-1]
                rest = wmax - len(text)
                text += " " * rest
                scr.addstr(hmax-2, 0, text, curses.A_REVERSE)
                scr.refresh()
                savewin.erase()
                overwrite = textbox.edit(checkch).strip()
                dosave = (overwrite.lower() in ("y", "yes"))
                
            if dosave and mlc.save(savefn):
                fn = savefn
                edited = False
        
        if rottop is not None:
            cam = rotateAround(cam, camright, math.pi * rottop / 90.)
            camtop = rotateAround(camtop, camright, math.pi * rottop / 90.)
        if rotright is not None:
            cam = rotateAround(cam, camtop, math.pi * rotright / 90.)
            camtop = rotateAround(camtop, camtop, math.pi * rotright / 90.)
    
    return isquit


def checkType(fn):
    fp = open(fn)
    typ = None
    flg = 0
    xyzcount = 0
    for l in fp:
        if flg == 0 and l.strip().isdigit():
            xyzcount += 1
            flg = -1 - int(l.strip())
        else:
            flg += 1
        if l.find("Entering Gaussian System") != -1:
            typ = "gaussian"
            break
        if l.find("Gaussian, Inc.") != -1:
            typ = "gaussian"
            break
        if l.find("PROGRAM SYSTEM MOLPRO") != -1:
            typ = "molpro"
            break
    if xyzcount == 1: typ = "xyz"
    if xyzcount > 1: typ = "xyztraj"
    fp.close()
    return typ
    

def main(scr, fn, typ):
    if typ in ("xyztraj",):
        traj(scr, fn, typ)
    elif typ in ("xyz", "gaussian", "molpro"):
        geomvib(scr, fn, typ)
    else:
        raise ValueError("Unsupported file type: %s" % typ)
    return


if __name__ == "__main__":
    verstr = "ttymol version %s\n" % __version__
    
    if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help"):
        sys.stdout.write(verstr)
        sys.stdout.write(__doc__)
        sys.exit()

    if sys.argv[1] in ("-v", "--version"):
        sys.stdout.write(verstr)
        sys.exit()
        
    if not _curses_supported:
        sys.stderr.write("Error: Curses is not supported on this platform.\n")
        sys.exit(1)

    fn = sys.argv[1]
    if not os.path.exists(sys.argv[1]):
        sys.stderr.write("Error: file not found: %s\n" % fn)
        sys.exit(1)
    typ = checkType(fn)
    if typ is None:
        sys.stderr.write("Unable to determine file type: %s\n" % fn)
        sys.exit(1)
    
    try:
        scr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        scr.keypad(1)
        scr.nodelay(1)
        main(scr, fn, typ)
    except KeyboardInterrupt:
        pass
    except:
        raise
    finally:
        curses.nocbreak()
        scr.keypad(0)
        curses.echo()
        curses.endwin()

